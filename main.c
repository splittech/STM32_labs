/*--------------------------ОПИСАНИЕ ПРОЕКТА----------------------------*/
/*	
	ОБЩЕЕ ОПИСАНИЕ:
		Данный проект представляет собой прошивку микроконтроллера серии 
		STM32 для использования его в качестве будильника.
	ПЕРИФЕРИЯ:
		светодиод, 5 кнопок
	РЕЖИМЫ РАБОТЫ:
		Стандартный режим - считает текущее время, при совпадении с временем 
							установленного будильника начинает подавать сигнал
							на светодиод (светодиод начинает мигать);
							при нажатии кнопки 5 будильник перестанет подавать сигнал,
							а время будильника сбросится
		Режим редактирования времени - позволяет отредактировать текущее время, циклически 
									   прибавляя минуту, 10 минут или час при помощи
									   кнопок 2, 3, 4 соответственно
		Режим редактирования будильника - позволяет отредактировать время будильника, циклически 
										  прибавляя минуту, 10 минут или час при помощи
										  кнопок 2, 3, 4 соответственно
		Смена режима работы происходит циклически при нажатии кнопки 1
*/
/*----------------------------------------------------------------------*/

#include "stm32f10x.h"

/*--------------------------НАСТРОЙКИ ПРОЕКТА---------------------------*/
uint32_t LED_pin = 5;				// Номер пина для светодиода
uint32_t BUTTON_1_pin = 6;			// Номер пина для кнопки (управление режимами)
uint32_t BUTTON_2_pin = 7;			// Номер пина для кнопки (добавить минуту)
uint32_t BUTTON_3_pin = 8;			// Номер пина для кнопки (добавить десять минут)
uint32_t BUTTON_4_pin = 9;			// Номер пина для кнопки (добавить час)
uint32_t BUTTON_5_pin = 10;			// Номер пина для кнопки (остановить будильник, сбросить будильник)
uint32_t debounce_limit = 10000;	// Лимит счетчика для программной обработки дребезга кнопки
/*----------------------------------------------------------------------*/

uint8_t mode; 	// Режим работы будильника, всего три режима:
				// 0 - стандартный режим работы будильника
				// 1 - режим редактирования текущего времени
				// 2 - режим редактирования времени будильника
				
uint8_t alarm_is_set;	// Флаг что будильник заведен 

// Структура для хранения времени
struct time{
	uint32_t hours;
	uint32_t minutes;
};
struct time current_time; 	// Текущее время
struct time alarm_time; 	// Время будильника

uint32_t total_seconds; 	// Количество посчитанных секунд (в текущих сутках)
uint8_t alarm_flag;		// Флаг, чтобы понять, когда подавать сигнал на светодиод

uint32_t button_count[5];	// Счетчики для обработки дребезга кнопок
uint16_t button_state;		// Состояние кнопки (бит соответствующего пина)

uint8_t button_1_is_handled;	// Флаги для обработки нажатий кнопок только один раз
uint8_t button_2_is_handled;	// в цикле до того, как соответствующая кнопка будет отжата
uint8_t button_3_is_handled;
uint8_t button_4_is_handled;
uint8_t button_5_is_handled;



/*----------------------------------------------------------------
 * SystemCoreClockConfigure: Функция для настройки частоты
 *----------------------------------------------------------------*/
void SystemCoreClockConfigure(void) {
	// Включаем HSI
	RCC->CR |= ((uint32_t)RCC_CR_HSION);
	// Ожидаем включения HSI
	while ((RCC->CR & RCC_CR_HSIRDY) == 0);

	// Устанавилваем HSI в качестве источника такстирования
	RCC->CFGR = RCC_CFGR_SW_HSI;
	// Ожидаем завершения
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI);

	// Настройка тактирования самого процессора и портов
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;  // HCLK = SYSCLK
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV1; // APB1 = HCLK
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV4; // APB2 = HCLK/4
	
	// В качестве источника тактирования был выбран HSI без использования множителей.
	// Такой выбор обусловлен требуемой автономностью устройства (частота ниже - меньше расход энергии),
	// в целом будильник не требует какой-то особой точности тактового сигнала, так что использование
	// относительно неточного HSI не должно вызвать проблем при работе.
}

/*----------------------------------------------------------------
 * TIM3_Init: функция для настройки таймера общего назначения TIM3
 * (для отсчета времени)
 *----------------------------------------------------------------*/
void TIM3_Init () {
	// Включаем таймер
	RCC -> APB1ENR |= RCC_APB1ENR_TIM3EN;
	// Включаем счетчик таймера
	TIM3 -> CR1 = TIM_CR1_CEN;
	
	// Настраиваем предделитель таймера для того, чтобы удобно задавать интервал прерываний
	// Прерывание будет вызываться каждую секунду
	TIM3->PSC = (SystemCoreClock) / 1000 - 1;
	// Задаем число на котором будут срабатывать прерывания (для удобства)
	TIM3->ARR = 1000 - 1;

	// Разрешаем прерывания
	TIM3->DIER |= TIM_DIER_UIE;
	NVIC_EnableIRQ (TIM3_IRQn);
}

/*----------------------------------------------------------------
 * TIM4_Init: функция для настройки таймера общего назначения TIM4
 * (для мигания светодиода)
 *----------------------------------------------------------------*/
void TIM4_Init () {
	// Включаем таймер
	RCC -> APB1ENR |= RCC_APB1ENR_TIM4EN;
	// Включаем счетчик таймера
	TIM4 -> CR1 = TIM_CR1_CEN;
	
	// Настраиваем предделитель таймера для того, чтобы удобно задавать интервал прерываний
	// SystemCoreClock / 2 означает, что обработчик прерывания будет вызываться каждые пол секунды
	TIM4->PSC = (SystemCoreClock / 2) / 1000 - 1;
	// Задаем число на котором будут срабатывать прерывания (для удобства)
	TIM4->ARR = 1000 - 1;

	// Разрешаем прерывания
	TIM4->DIER |= TIM_DIER_UIE;
	NVIC_EnableIRQ (TIM4_IRQn);
}

/*----------------------------------------------------------------
 * Enable_pin_input: Функция для включения пина на вход по его 
 *									 номеру (порт A)
 * pin_number: номер пина, который нужно настроить
 *----------------------------------------------------------------*/
void Enable_pin_input(uint32_t pin_number){
	// Половина пинов порта на регистре CRL, другая половина на CRH
	if(pin_number < 8ul){
		// Отчищаем часть регистра для соответствующего пина
		GPIOA->CRL &= ~((15ul << 4*pin_number));
		// MODE = 00: input mode
		GPIOA->CRL |= (( 0ul << 4*pin_number));
		// INPUT MODE = 10: input with pull up/pull down
		GPIOA->CRL |= (( 8ul << 4*pin_number));
	}
	else{
		// То же самое для регистра CRH
		pin_number -= 8ul;
		GPIOA->CRH &= ~((15ul << 4*pin_number));
		GPIOA->CRH |= (( 0ul << 4*pin_number));
		GPIOA->CRH |= (( 8ul << 4*pin_number));
	}
}

/*----------------------------------------------------------------
 * Enable_pin_output: Функция для включения пина на выход по его 
 *									  номеру (порт A)
 * pin_number: номер пина, который нужно настроить
 *----------------------------------------------------------------*/
void Enable_pin_output(uint32_t pin_number){
	// Половина пинов порта на регистре CRL, другая половина на CRH
	if(pin_number < 8ul){
		// Отчищаем часть регистра для соответствующего пина
		GPIOA->CRL &= ~((15ul << 4*pin_number));
		// MODE = 01: output mode (10MHz)
		GPIOA->CRL |= (( 1ul << 4*pin_number));
		// OUTPUT MODE = 00: output push-pull
		GPIOA->CRL |= (( 0ul << 4*pin_number));
	}
	else{
		// То же самое для регистра CRH
		pin_number -= 8ul;
		GPIOA->CRH &= ~((15ul << 4*pin_number));
		GPIOA->CRH |= (( 1ul << 4*pin_number));
	}
}

/*----------------------------------------------------------------
 * GPIO_Init: Функция для настройки портов ввода-вывода
 *----------------------------------------------------------------*/
void GPIO_Init (void) {
	// Разрешаем тактирование порта A
	RCC->APB2ENR |= (1 << 2);
	
	// Настраиваем пин на выход (для светодиода)
	Enable_pin_output(LED_pin);
	// Настраиваем пинs на вход (для кнопок)
	Enable_pin_input(BUTTON_1_pin);
	Enable_pin_input(BUTTON_2_pin);
	Enable_pin_input(BUTTON_3_pin);
	Enable_pin_input(BUTTON_4_pin);
	Enable_pin_input(BUTTON_5_pin);
}

/*----------------------------------------------------------------
 * Switch_pin: Функция, которая подает инвертированное значение на указанный пин
 *						 (если было 0, станет 1 и наоборот)
 * pin_number: номер пина, на котором инвертировать сигнал
 *----------------------------------------------------------------*/
void Switch_pin (uint32_t pin_number) {
	if(GPIOA->ODR & (1 << pin_number)){
		GPIOA->BSRR = 1 << (pin_number + 16);
	}
	else{
		GPIOA->BSRR = 1 << pin_number;
	}
}

/*----------------------------------------------------------------
 * TIM3_IRQHandler: Обработчик прерываний таймера TIM3
 * (Вызывается каждую секунду)
 *----------------------------------------------------------------*/
void TIM3_IRQHandler () {
	// Сброс флага прерывания
	TIM3->SR &= ~TIM_SR_UIF;

	// Добавляем время, только если находимся не в режиме редактирования
	if(mode == 0){
		total_seconds++;
		if(total_seconds == 86400){
			// Сбрасываем, если начались новые сутки (в сутках 60*60*24=86400 секунд)
			total_seconds = 0;
		}
	// Храним время в структуре для удобства
	current_time.minutes = total_seconds / 60 % 60;
	current_time.hours = total_seconds / 3600;
	}
	// Прибавляем количество секунд в данных сутках
	
	// В обработчике достаточно много действий, однако я решил не писать их
	// в main, потому что они должны выполнятся строго друг за другом, чтобы не было ошибок.
	// Если написать их в main, то прерывание TIM3, отработавшее между данными действиями может
	// привести к неккоректному отображению времени. Таким образом частота SYSCLK составит 8МГц
}

/*----------------------------------------------------------------
 * TIM4_IRQHandler: Обработчик прерываний таймера TIM4
 * (вызывается каждые полсекунды)
 *----------------------------------------------------------------*/
void TIM4_IRQHandler () {
	// Сброс флага прерывания
	TIM4->SR &= ~TIM_SR_UIF;
	
	// Мигаем светодиодом, если будильник звенит, второе условие для гарантированного отключения
	// чтобы последним действием было отключение светодиода, а не включение (чтобы не светился в конце)
	if(alarm_flag == 1 || GPIOA->ODR & (1ul << LED_pin)){
			Switch_pin(LED_pin);
	}
}

/*----------------------------------------------------------------
 * Debounce_handler: функция для программной обработки дребезга кнопки
 *
 * button_state: сигнал на пине кнопки, 0 - нет сигнала, иначе есть
 * button_number: номер кнопки (необходимо для независимых счетчиков)
 *----------------------------------------------------------------*/
uint8_t Debounce_handler(uint16_t button_state, uint8_t button_number){
	if(button_state == 0){
		if(button_count[button_number] > 0){
			button_count[button_number]--; // Уменьшаем пока не достигнем 0
			return 1;
		}
		else{
			return 0; // Кнопка гарантированно не нажата
		}
	}
	else{
		if(button_count[button_number] < debounce_limit){
			button_count[button_number]++; // Увеличиваем пока не достигнем установленного лимита
			return 0;
		}
		else{
			return 1; // Кнопка гарантированно нажата
		}
	}
}

/*----------------------------------------------------------------
 * Switch_mode: функция для переключения режима работы
 *----------------------------------------------------------------*/
void Switch_mode(void){
	// Переключаем режим
	mode++;
	// Переключение режимов происходит циклически (0 -> 1 -> 2 -> 0)
	if(mode == 3){
		mode = 0;
	}
	// При переходе в режим редактирования будильника сразу заводим его
	// (я не стал делать дополнительное подстверждение)
	if(mode == 2){
		alarm_is_set = 1;
	}
	// Каждый раз при переключении режима сбрасываем количество секунд в текущей минуте.
	total_seconds = total_seconds - total_seconds % 60;
}

/*----------------------------------------------------------------
 * Add_clock_time: функция для настройки часов, добавляет необходимое
 *								 количество времени в минутах к текущему времени
 * ammount: количество времени в минутах, которое необходимо добавить
 *----------------------------------------------------------------*/
void Add_clock_time(uint8_t ammount){
	// Прибавляем указанное значение минут
	current_time.minutes += ammount % 60;
	// Прибавляем указанное значение часов
	current_time.hours += ammount / 60;
	// Обработка переполнения
	if(current_time.minutes >= 60){
		// Переполняются отдельно минуты, отдельно десятки минут для удобства использования
		if(ammount == 10){
			current_time.minutes -= 60;
		}
		else{
			current_time.minutes -= 10;
		}
	}
	if(current_time.hours >= 24){
		current_time.hours -= 24; 
	}
	// Обновляем счетчик
	total_seconds = current_time.hours * 3600 + current_time.minutes * 60;
}

/*----------------------------------------------------------------
 * Add_alarm_time: функция для настройки будильника, добавляет необходимое
 *								 количество времени в минутах к времени будильника
 * ammount: количество времени в минутах, которое необходимо добавить
 *----------------------------------------------------------------*/
void Add_alarm_time(uint8_t ammount){
	// Прибавляем указанное значение минут
	alarm_time.minutes += ammount % 60;
	// Прибавляем указанное значение часов
	alarm_time.hours += ammount / 60;
	// Обработка переполнения
	if(alarm_time.minutes >= 60){
		// Переполняются отдельно минуты, отдельно десятки минут для удобства использования
		if(ammount == 10){
			alarm_time.minutes -= 60;
		}
		else{
			alarm_time.minutes -= 10;
		}
	}
	if(alarm_time.hours >= 24){
		alarm_time.hours -= 24; 
	}
}

int main (void) {
	// Устанавливаем частоту
	SystemCoreClockConfigure();
	SystemCoreClockUpdate();

	// Настраиваем порты ввода вывода
	GPIO_Init();

	// Настраиваем таймеры
	TIM3_Init();
	TIM4_Init();

	while (1) {
		// Проверяем нажатие первой кнопки (переключение режима)
		button_state = READ_BIT(GPIOA->IDR, 1 << BUTTON_1_pin);
		// Обрабатываем дребезг
		if(Debounce_handler(button_state, 0)){
			// Данная конструкция необходима, чтобы обработать нажатие только один раз
			if(button_1_is_handled == 0){
				// Меняем режим
				Switch_mode();
				button_1_is_handled = 1;
			}
		}
		else{
			// Когда отпускаем кнопку, появляется возможность снова обработать нажатие
			button_1_is_handled = 0;
		}
		
		// Проверяем, что находимся не в режиме редактирования
		if(mode == 0){
			// Проверяем, что будильник заведен
			if(alarm_is_set == 1){
				// Проверяем равно ли текущее время и время будильника
				if(current_time.hours == alarm_time.hours && current_time.minutes == alarm_time.minutes){
					alarm_flag = 1;	
				}
			}
			// Проверяем нажатие пятой кнопки (кнопка отключения будильника)
			button_state = READ_BIT(GPIOA->IDR, 1 << BUTTON_5_pin);
			if(button_state != 0){
				// Cбрасываем сигнал будильника и сам будильник
				alarm_flag = 0;
				alarm_is_set = 0;
				alarm_time.hours = 0;
				alarm_time.minutes = 0;
			}
		}
		// Если в режиме редактирования
		else{
			// Проверяем нажатие второй кнопки (добавить минуту)
			button_state = READ_BIT(GPIOA->IDR, 1 << BUTTON_2_pin);
			// Обрабатываем дребезг
			if(Debounce_handler(button_state, 1)){
				// Данная конструкция необходима, чтобы обработать нажатие только один раз
				if(button_2_is_handled == 0){
					// В зависимости от выбранного режима
					if(mode == 1){
						// Добавляем минуту к текущему времени
						Add_clock_time(1);
					}
					else{
						// Или добавляем минуту к времени будильника
						Add_alarm_time(1);
					}
					button_2_is_handled = 1;
				}
			}
			else{
				// Когда отпускаем кнопку, появляется возможность снова обработать нажатие
				button_2_is_handled = 0;
			}
			
			// Проверяем нажатие третьей кнопки (добавить 10 минут)
			button_state = READ_BIT(GPIOA->IDR, 1 << BUTTON_3_pin);
			// Обрабатываем дребезг
			if(Debounce_handler(button_state, 2)){
				// Данная конструкция необходима, чтобы обработать нажатие только один раз
				if(button_3_is_handled == 0){
					// В зависимости от выбранного режима
					if(mode == 1){
						// Добавляем десять минут к текущему времени
						Add_clock_time(10);
					}
					else{
						// Или добавляем десять минут к времени будильника
						Add_alarm_time(10);
					}
					button_3_is_handled = 1;
				}
			}
			else{
				// Когда отпускаем кнопку, появляется возможность снова обработать нажатие
				button_3_is_handled = 0;
			}
			
			// Проверяем нажатие четвертой кнопки (добавить час)
			button_state = READ_BIT(GPIOA->IDR, 1 << BUTTON_4_pin);
			// Обрабатываем дребезг
			if(Debounce_handler(button_state, 4)){
				// Данная конструкция необходима, чтобы обработать нажатие только один раз
				if(button_4_is_handled == 0){
					// В зависимости от выбранного режима
					if(mode == 1){
						// Добавляем час к текущему времени
						Add_clock_time(60);
					}
					else{
						// Или добавляем час к времени будильника
						Add_alarm_time(60);
					}
					button_4_is_handled = 1;
				}
			}
			else{
				// Когда отпускаем кнопку, появляется возможность снова обработать нажатие
				button_4_is_handled = 0;
			}
		}
	}
}